*cmdline.txt*   For Vim version 7.0.  最近更新: 2006年7月31日


		  	VIM 参 考 手 册    	by Bram Moolenaar

				翻译: Dasn, tocer  http://vimcdoc.sf.net
					


				*Cmdline-mode* *Command-line-mode*
命令行模式		*Cmdline* *Command-line* *mode-cmdline* *:*

命令行模式可以用来输入 Ex 命令 (":")，搜索符合样式的字符串("/" 和 "?")，
和过滤命令("!")。

一些基本的、与命令行编辑相关的内容在用户手册的第 20 章里有所描述，见: 
|usr_20.txt|。

1. 命令行编辑			|cmdline-editing|
2. 命令行补全			|cmdline-completion|
3. Ex 命令行			|cmdline-lines|
4. Ex 命令行的区间		|cmdline-ranges|
5. Ex 命令行的标志		|ex-flags|
6. Ex 特殊字符			|cmdline-special|
7. 命令行窗口			|cmdline-window|

==============================================================================
1. 命令行编辑						*cmdline-editing*

通常，字符会在光标位置前插入。你可以用键盘上的左右键来移动光标的位置。还可以
通过 <Insert> 键，在 "插入" 和 "替换" 两种模式之间切换。
{Vi: 只能改变每一行的最后一个字符}

注意，如果你的键盘上没有可以移动光标的键或其它特殊键，你可以用 ":cnoremap" 定
义另外一个键来代替它们。例如，定义一组 tcsh 风格的键: 	*tcsh-style*  >
	:cnoremap <C-A> <Home>
	:cnoremap <C-F> <Right>
	:cnoremap <C-B> <Left>
	:cnoremap <Esc>b <S-Left>
	:cnoremap <Esc>f <S-Right>
(<> 是标识符，见 |<>|; 上面的例子要一字不落地输入)

							*cmdline-too-long*
当命令行指令长度大于屏幕的宽度时，只有合适的部分被显示出来。光标只能在命令的
可视部分移动，所以你不能编辑其他部分。

						*cmdline-history* *history*
在命令行里输入的命令会存储在历史记录中，你可以使用上下箭头键来翻阅它们。有五个
历史表: 
- 一个是为 ':' 命令准备的
- 一个是为搜索字符串准备的
- 一个是为表达式准备的
- 一个是为输入行准备的，用来输入 |input()| 函数。
- 一个是为调试模式下的命令准备的

这些记录是完全分开的。每一种输入模式只能访问与之相关的一个记录。
选项 'history' 用来设定保存历史记录的行数 (默认值: 20 ) 。

注意:
- 如果你输入了一条命令与历史记录中已有的命令完全相同，那么历史记录中的这条旧
  命令会被删除 (这样做是为了避免历史列表被大量的重复指令占据) 。
- 只有键入的命令才会记录下来。完全来自映射的命令不会。
- 所有的搜索操作都会放到与搜索相关的历史记录中，包括通过 "*" 和 "#" 进行的搜
  索。但是对于映射，只有最近一次的搜索会被记录下来 (这样是为了避免很长的映射
  把历史记录搞乱) 。
{Vi: 没有历史记录}
{not available: 若编译的时候没有加入 |+cmdline_hist|，则该功能不可用}

命令行的自动匹配功能；见 |cmdline-completion|。

							*c_CTRL-V*
CTRL-V		逐个插入非数字字符。用三个十进制数表示一个字节。该非数字字符
		和这三个十进制数字不作为映射处理。这与插入模式下的工作方式相
		同 (见 |i_CTRL-V|)。
		注意: 由于在 Windows 系统下，CTRL-V 被映射为"粘贴文本"，所
		以我们要用 CTRL-Q 代替 CTRL-V 。
							*c_CTRL-Q*
CTRL-Q		与 CTRL-V 相同。但是有些终端把它定义为控制字符，那样就无法使用
		了。

							*c_<Left>*
<Left>		光标左移
							*c_<Right>*
<Right>		光标右移
							*c_<S-Left>*
<S-Left> 或 <C-Left>					*c_<C-Left>*
		光标左移一个单词
							*c_<S-Right>*
<S-Right> 或 <C-Right>					*c_<C-Right>*
		光标右移一个单词
CTRL-B 或 <Home>					*c_CTRL-B* *c_<Home>*
		光标移动至命令的起始
CTRL-E 或 <End>						*c_CTRL-E* *c_<End>*
		光标移动至命令的末尾

							*c_<LeftMouse>*
<LeftMouse>	将光标置于点击鼠标的地方

CTRL-H							*c_<BS>* *c_CTRL-H*
<BS>		删除光标前面的字符(如果你的 <BS> 键不能正常工作，请参阅 
		|:fixdel| )。
							*c_<Del>*
<Del>		删除光标下的字符(如果光标处于行的末尾，则删除光标前的字符)
		(如果你的 <Del> 键不能正常工作，请参阅 |:fixdel|)。
							*c_CTRL-W*
CTRL-W		删除光标前的单词
							*c_CTRL-U*
CTRL-U		删除光标所在位置与行首之间的所有字符。先前一些版本的 vim 删
		除整行的所有字符。如果你喜欢原先的这种方式，可以把下面的命令
		加入到你的 .vimrc :  >
			:cnoremap <C-U> <C-E><C-U>
<
		注意:  如果命令行里已经没有字符，那么用一个删除命令可以退出
		命令行模式。
							*c_<Insert>*
<Insert>	在插入和替换之间切换。{Vi 没有该功能}

{char1} <BS> {char2}	或				*c_digraph*
CTRL-K {char1} {char2}					*c_CTRL-K*
		输入 二合字母 (见 |digraphs|)。如果 {char1} 是一个特殊键，
		则该键的编码以 <> 的形式插入。 {Vi 没有该功能}

CTRL-R {0-9a-z"%#:-=.}					*c_CTRL-R* *c_<C-R>*
		插入寄存器里的内容。当按下 CTRL-R 时，屏幕会显示一个 '"' 字
		符，提示你输入一个寄存器的名字。
		插入的文字就像是你自己输入的，但是映射和缩写不会生效。同样
		也不会触发 'wildchar' 的补全功能。并且那些可以结束命令的字符
		会被按字面插入(<Esc>，<CR>，<NL>，<C-C>)。虽然 <BS> 或
		 CTRL-W 仍旧可能结束命令行模式，但是剩余的字符会被接下来其他
		的模式解释，这可能并非你的目的。
		特殊寄存器: 

			'"'	未命名的寄存器，包含最近一次删除或复制的内容
			'%'	当前文件名
			'#'	备选文件名
			'*'	剪贴板的内容(X11: 主选区)
			'+'	剪贴板的内容
			'/'	最近一次的查找模板
			':'	最近一次在命令行输入的命令
			'-'	最近一次小的(少于一行)删除
			'.'	最近插入的文本
							*c_CTRL-R_=*
			'='	表达式寄存器: 会提示你输入一个表达式。
				(见 |expression|)
			(在表达式提示中无效；不允许改变缓冲区或者当前窗口这样
			的操作，以避免副作用)
		与寄存器相关的内容请参见 |registers|。{Vi 无此功能}
		实现细节：如果使用 |expression| 寄存器并且调用 setcmdpos()，那
		么在插入返回的文本之前设置光标位置。使用 CTRL-R CTRL-R 在插入
		返回的文本之后设置光标位置。

CTRL-R CTRL-F				*c_CTRL-R_CTRL-F* *c_<C-R>_<C-F>*
CTRL-R CTRL-P				*c_CTRL-R_CTRL-P* *c_<C-R>_<C-P>*
CTRL-R CTRL-W				*c_CTRL-R_CTRL-W* *c_<C-R>_<C-W>*
CTRL-R CTRL-A				*c_CTRL-R_CTRL-A* *c_<C-R>_<C-A>*
		插入光标下的对象: 
			CTRL-F	光标下的文件名
			CTRL-P	用 'path' 扩展的光标下的文件名。与 |gf|
				中的类似。
			CTRL-W	光标下的单词
			CTRL-A	光标下的_单词_; 参见: |WORD|

		如果设置了 'incsearch'，把当前显示的匹配末尾确定为光标位置。
		使用 CTRL-W ，已经录入的单词部分不再重复插入。
		{Vi 无此功能}
		CTRL-F 和 CTRL-P: {只有包含了 +file_in_path ，该功能才可用}

					*c_CTRL-R_CTRL-R* *c_<C-R>_<C-R>*
					*c_CTRL-R_CTRL-O* *c_<C-R>_<C-O>*
CTRL-R CTRL-R {0-9a-z"%#:-=. CTRL-F CTRL-P CTRL-W CTRL-A}
CTRL-R CTRL-O {0-9a-z"%#:-=. CTRL-F CTRL-P CTRL-W CTRL-A}
		插入寄存器或光标下的对象。类似于 |c_CTRL-R|，但是该命令按字面
		插入文本。例如，如果寄存器 a 的内容为 "xy^Hz" (^H 是
		退格键)，那么 "CTRL-R a" 会插入 "xz"，而 "CTRL-R CTRL-R a"
		会插入 "xy^Hz"。

CTRL-\ e {expr}						*c_CTRL-\_e*
		计算表达式 {expr} 并用结果替换整个命令行。程序会提示你输入表
		达式，用 <Enter> 键提交表达式。这项功能在映射里十分有用。参
		见 |expression|。
		欲了解插入表达式结果的相关信息，请参阅 |c_CTRL-R_=|。
		|getcmdtype()|，|getcmdline()| 和 |getcmdpos()| 函数在这里很
		有用。
		光标的位置不会改变，除非光标正位于行末，那么它会停留在行末。
		可以用 |setcmdpos()| 来设置光标的位置。
		使用沙盘 |sandbox| 计算表达式以避免讨厌的副作用。
		例如:  >
			:cmap <F7> <C-\>eAppendSome()<CR>
			:func AppendSome()
			   :let cmd = getcmdline() . " Some()"
			   :" place the cursor on the )
			   :call setcmdpos(strlen(cmd))
			   :return cmd
			:endfunc
<		它无法递归操作，所以如果正在编辑一个表达式，它将无效。

							*c_CTRL-Y*
CTRL-Y		当存在一个非模式选择时，复制该选择区域的内容至剪贴板。
		参考 非模式 |modeless-selection|。
		如果没有选择，那么 CTRL-Y 会被当作字符直接插入。

CTRL-J						*c_CTRL-J* *c_<NL>* *c_<CR>*
<CR> 或 <NL>	执行输入的命令
							*c_<Esc>*
<Esc>		如果 'cpoptions' 选项中不包括 'x'，那么输入该键会退出命令行
		模式，而不执行命令。若 'cpoptions' 里包含 'x'，或者该键出
		现在宏命令里，则执行输入的命令。
							*c_CTRL-C*
CTRL-C		不执行命令，退出命令行模式

							*c_<Up>*
<Up>		在历史记录中查找与当前输入匹配的前一条命令。(见下面)
		{如果编译时没有加入 |+cmdline_hist| 功能，则不可用}
							*c_<Down>*
<Down>		在历史记录中查找与当前输入匹配的下一条命令。(见下面)
		{如果编译时没有加入 |+cmdline_hist| 功能，则不可用}

							*c_<S-Up>* *c_<PageUp>*
<S-Up> 或 <PageUp>
		从历史记录中查找上一条命令
		{如果编译时没有加入 |+cmdline_hist| 功能，则不可用}
						*c_<S-Down>* *c_<PageDown>*
<S-Down> 或 <PageDown>
		从历史记录中查找下一条命令
		{如果编译时没有加入 |+cmdline_hist| 功能，则不可用}

CTRL-D		命令行补全(见 |cmdline-completion|)
'wildchar' 选项
		命令行补全(见 |cmdline-completion|)
CTRL-N		命令行补全(见 |cmdline-completion|)
CTRL-P		命令行补全(见 |cmdline-completion|)
CTRL-A		命令行补全(见 |cmdline-completion|)
CTRL-L		命令行补全(见 |cmdline-completion|)

							*c_CTRL-_*
CTRL-_		a - 在希伯来语和英语的键盘模式之间切换，这只是针对命令行
		模式，与 hkmap 无关。
		如果命令行、搜索、缩写，等等需要输入希伯来文的话，这一功能
		就很有用了。Vim 只有在编译时加入了 |+rightleft|，并且设置
		了 'allowrevins' 选项后，该功能才可用。
		参见 |rileft.txt|。

		b - 在法尔西语(波斯语)和英语的键盘模式之间切换，这只是针
		对命令行模式，与 fkmap 无关。在法尔西语键盘模式下，字符的插
		入方式与平时相反(即从右至左)。如果命令行、搜索、缩写，等等
		需要输入法尔西文的话，这一功能就很有用了。
		Vim 只有在编译时加入了 |+farsi|，该功能才可用。
		参见 |farsi.txt|。

							*c_CTRL-^*
CTRL-^		语言映射 |:lmap| 和/或 输入法的开关。
		在输入搜索模板的时候，如果 'imsearch' 的值不是 -1 ，那么其值
		是 'imsearch' 的值，否则，其值是 'iminsert' 的值。
		如果定义了语言映射: 
		- 如果其值为 1 (使用 langmap 映射)，那么变为 0 (不使用
		langmap 映射)。
		- 如果其值不是 1，那么会变为 1，这样 langmap 映射被启用。
		如果没有定义语言映射: 
		- 如果其值是 2 (使用输入法)，那么变为 0 (不使用输入法)
		- 如果是其它值，那么变为 2，这样输入法被启用。
		{not in Vi}
		这些语言映射通常被用来输入不同键盘产生的不同的字符。可以用
		'keymap' 选项安装一整套这样的映射。当输入一行命令时，langmap
		映射关闭，因为你是想输入一条命令。当你用 CTRL-^ 打开映射后，新
		的状态不会被下一条命令或搜索模板再次使用。
		{Vi 无此功能}

对于 Emacs 风格的命令行编辑请参阅 |emacs-keys|。

<Up> 和 <Down> 键把当前的命令行作为搜索的字符串。前一条或后一条命令的起始部分
与该字符串做比较。最先匹配的作为新的命令。若连续重复这两个键，则使用同一字符串
进行再次匹配。例如，寻找前一个替换命令: 输入":s" 然后 <Up>。同样也可以重复输入
一连串 <S-Up> 直至找到你需要的命令为止。(注意: Shift+箭头键 在某些终端里不可用)

							*his* *:history*
:his[tory]	列出最近执行的命令。
		{Vi 无此功能}
		{not available 若编译时未加入 |+cmdline_hist|，则无此功能}

:his[tory] [{name}] [{first}][, [{last}]]
		列出 {name} 历史记录的内容，{name} 可以是: 
		c[md]	 或 :	命令行的历史记录
		s[earch] 或 /	查找字符串的历史记录
		e[xpr]	 或 =	表达式寄存器的历史记录
		i[nput]	 或 @	输入行的历史记录
		d[ebug]	 或 >	调试命令的历史记录
		a[ll]		所有上述记录
		{Vi 无此功能}

		如果给定了数字 {first} 和 {last}，那么就会列出指定范围内的历
		史记录条目。这些数字可以是下面的格式: 
							*:history-indexing*
		表示历史记录索引的一个正数，也就是 :history 命令列出的第一列
		数字。即使历史记录中的其它条目被删除了，该数字也会保持不变。

		表示与某一记录的相对位置的一个负数。以最新的一条记录(索引号
		为 -1)为标准向后算起。

		例子: 
		列出搜索历史记录中的第 6 到第 12 条记录:  >
			:history / 6,12
<
		列出所有历史记录中最近的 5 条记录:  >
			:history all -5,

==============================================================================
2. 命令行补全						*cmdline-completion*

在编辑命令行的时候，有一些命令可以用来补全光标前面的单词。此功能在下述情况中
可用: 

- 命令名称: 在命令行的起始处。
- 标签: 只在 ":tag" 命令后。
- 文件名: 只在可以接受文件名的命令或可以接受文件名的选项之后。也被称作文件
  名补全。
- Shell 命令名：在 ":!cmd", ":r !cmd" and ":w !cmd" 之后。使用 $PATH。
- 选项: 仅在 ":set" 命令之后。
- 映射: 仅在 ":map" 或与之类似的命令之后。
- 变量和函数名: 仅在 ":if"，":call" 或类似的命令之后。

如果在编译 Vim 时没有加入 |+cmdline_compl| 功能，则只有文件名、目录、和帮助
条目可以补全。

以下是可以使用的命令: 

							*c_CTRL-D*
CTRL-D		列出与光标前面的样式所匹配的名字。
		在列文件名的时候，目录名会被加亮(见 'highlight' 选项)。扩
		展名与 'suffixes' 匹配的文件名放到列表的最后。
		要列出匹配标签所在的文件，可以设置选项 'wildoptions' 为 
		"tagfile"。

					*c_CTRL-I* *c_wildchar* *c_<Tab>*
'wildchar' 选项
		用光标前的样式完成匹配。匹配的项目 (如果有多项匹配，则选第
		一项) 会插入并取代样式。(注意: 该功能不能用于宏，因为在大多
		数情况下 <Tab> 或 <Esc> 被用做 'wildchar'，并且这些键在某些
		宏里面有特殊的意义。)	如果再次输入，并且有多项匹配时，则
		插入下一项匹配。在最后一项匹配之后，会再次匹配第一项(循环使
		用)。
		该行为可以通过设置 'wildmode' 选项来改变。
							*c_CTRL-N*
CTRL-N		在使用 'wildchar' 之后，如果得到了多项匹配，则选择下一项匹
		配。否则选择命令历史列表中的下一条命令。
<S-Tab>							*c_CTRL-P* *c_<S-Tab>*
CTRL-P		在使用 'wildchar' 之后，如果得到了多项匹配，则选择前一项匹
		配。否则选择命令历史列表中的上一条命令。<S-Tab> 只在 Amiga 
		的 GUI 和 MS-DOS 里可以用。
							*c_CTRL-A*
CTRL-A		所有与样式匹配的项全部插入到光标前面。
							*c_CTRL-L*
CTRL-L		用光标前的样式完成匹配。如果有匹配的项目，则插入并取代当前
		的样式。如果有多个项目匹配，那么取这些项目中尽可能长的共同
		部分插入，以取代样式。若结果比样式短，则匹配不成功。
		如果设置 'incsearch'，然后使用 "/" 或者 "?" 录入搜索模式并且显
		示出当前的匹配，那么 CTRL-L 会从当前匹配的末尾增加一个字符。

选项 'wildchar' 的默认值是 <Tab> (在 Vi 兼容模式里用的是 CTRL-E; 在以前的
版本里用的是 <Esc> )。 在匹配模式里可以使用标准的通配符 '*' 和 '?'。'*' 匹配
任意字符串，'?' 匹配一个字符。

如果你喜欢 tcsh 的自动列表匹配，可以使用这个映射:  >
	:cnoremap X <C-L><C-D>
( X 是命令键，<C-L> 是 CTRL-L ，<C-D> 是 CTRL-D )这样就可以找到最长的匹配并
列出所有匹配的文件。

如果你喜欢 tcsh 的自动列表匹配，你可以使用 'wildmode' 选项来模拟它。例如，
这与 autolist=ambiguous 极其类似:  >
	:set wildmode=longest,list
这将在你输入第一个 'wildchar' 之后，找到最长的匹配，接着列出所有匹配的文件。

							*suffixes*
对于文件名的匹配你可以用 'suffixes' 选项在相似的文件名之间设定优先级。如
果有多个文件匹配，并且 'suffixes' 选项中包含这些文件的扩展名，那么这些文件会
被忽略。'suffixes' 的默认值是 ".bak，~，.o，.h，.info，.swp，.obj"。其含义是: 
以 ".bak"，"~"，".o"，".h"，".info"，".swp" 和 ".obj" 结尾的文件名有时被忽略。
不能忽略后缀名为两点的文件名。例如: 

   样式:	文件:				匹配:	~
   test*	test.c test.h test.o		test.c
   test*	test.h test.o			test.h and test.o
   test*	test.i test.h test.c		test.i and test.c

如果有多个文件匹配 (在忽略了与 'suffixes' 匹配的扩展名之后)，则第一个匹配的
文件名被插入。当你按两次 'wildchar' 时，你可以看到只有一个匹配并且完整的匹配
保持不变。你可以再输入一次 'wildchar'，CTRL-N，或 CTRL-P 得到另一个匹配。包
括所有的文件，也包括扩展名与 'suffixes' 匹配的文件。

要完全忽略有某些扩展名的文件，请使用 'wildignore' 选项。

一个选项的旧值可以通过在 '=' 后面输入 'wildchar' 来获得。例如，在 ":set dir="
后输入 'wildchar'，就会插入当前 'dir' 的值。对于选项值是文件名的选项，这一行为
优先于文件名匹配。

若你喜欢在 xterm 里使用 <S-Tab> 代替 CTRL-P，把这条命令放到你的 .cshrc 里:  >
	xmodmap -e "keysym Tab = Tab Find"
把这条命令放到你的 .vimrc 里:  >
	:cmap <Esc>[1~ <C-P>

==============================================================================
3. Ex 命令行						*cmdline-lines*

Ex 命令有几个特别的地方: 

							*:quote*
如果 '"' 出现在一行的开始，那么该行被忽略。如果 '"' 出现在命令之后，则使得
该行的剩余部分被忽略。这可以被用于添加注释。例如:  >
	:set ai		"set 'autoindent' option
不能给 shell 命令 (":!cmd") 或 ":map" 之类的命令添加注释，因为它们把 '"' 视
为命令的一部分。

							*:bar* *:\bar*
'|' 可以用来分割命令，所以你可以在一行里输入多个命令。如果你想在参数里使用
'|' ，应该在前面加上 '\'。

下面这些命令把 '|' 当作它们的参数，所以后面不能跟别的命令: 
    :argdo
    :autocmd
    :bufdo
    :command
    :cscope
    :debug
    :folddoopen
    :folddoclosed
    :function
    :global
    :help
    :helpfind
    :lcscope
    :make
    :normal
    :perl
    :perldo
    :promptfind
    :promptrepl
    :pyfile
    :python
    :registers
    :read !
    :scscope
    :tcl
    :tcldo
    :tclfile
    :vglobal
    :windo
    :write !
    :[range]!
    没有参数 "-bar" 的用户自定义命令 |:command|

注意: 在 ":g" 中 '|' 包含在命令里(作为参数)，但":s" 却不是。这的确有点乱
 ( 继承于Vi )。

为确保另一个命令能够执行，请使用 ":execute" 命令。
例如 (读入 "ls" 的输出，并且跳到第一行): >
	:execute 'r !ls' | '[

有一个例外: 如果 'b' 出现在 'cpoptions' 选项中，那么在 ":map" 和 ":abbr" 之
类的命令里需要用 CTRL-V 代替 '\'。你也可以用 "<Bar>" 来代替。参见 |map_bar|。

例如: >
	:!ls | wc		查看两个命令的输出
	:r !ls | wc		将相同的输出插入文本
	:%g/foo/p|>		将所有匹配的行移动一个 shiftwidth
	:%s/foo/bar/|>		将一行移动一个 shiftwidth
	:map q 10^V|		将 "q" 映射为 "10|"
	:map q 10\| map \ l	将 "q" 映射为 "10\" 和将 "\" 映射为 "l"
					(如果 'cpoptions' 选项中包含 'b')

用与 '|' 相同的方法，你也可以用 <NL> 分割多个命令。用 CTRL-V CTRL-J 插入一个
<NL>。Vim 会显示一个 "^@"。应该说，使用 '|' 是一个更好的方法。但是对于外部命
令，就必须使用 <NL>，因为外部命令会包含 '|'。如果要避免 <NL> 的特殊含义，就必
须在它前面加反斜杠。例如:  >
	:r !date<NL>-join
将当前时间读入文件，并且上一行文本衔接。

注意: 如果 '|' 前面的命令产生了错误，那么其后面的命令不会执行。


为了兼容 Vi，下面几个奇怪的命令 Vim 也支持: >
	:|			打印当前行 (同 ":p")
	:3|			打印第 3 行 (同 ":3p")
	:3			前进至第 3 行

在区间与命令之间允许有一个冒号。 这个冒号是被忽略的 (于 Vi 兼容)。例如: >
	:1,$:s/pat/string

当字符 '%' 或 '#' 被用在一个需要文件名的地方时，会被扩展为当前的文件名或备
选文件名(参见 "编辑文件" 的章节 |:_%| |:_#|)。

在 Amiga 系统里，如果文件名要作为参数使用，那么文件名里是允许包含空格符的。
通常末尾的空格符会被忽略，除非使用转意字符反斜杠或 CTRL-V 使它转意。注意，
":next" 命令使用空格符分割文件名。所以要在该命令里使用带空格符的文件名，就
需要将空格符转意。例如: >
	:next foo\ bar goes\ to school\
开始编辑 "foo bar"，"goes to" 和 "school " 三个文件。

当你想在命令里使用特殊字符 '"' 或 '|'，或者想在文件名里使用 '%' 或 '#'，
就需要在这些字符前加一个反斜杠。在区间和 "substitution" 命令里不需要使用反
斜杠。

							*:_!*
在 Ex 命令之后的 '!' (叹号) 使得命令以不同的方式执行。'!' 应该紧跟在命令之
后，中间没有任何空白字符。如果插入了空白字符，'!' 则被视为该命令的参数，其
含义是不同的。例如: >
	:w! name	将当前缓冲区内容写入文件 "name"。若该文件存在，则覆
			盖之。
	:w !name	将当前缓冲区内容作为标准输入发送给 "name" 命令。

==============================================================================
4. Ex 命令行的区间		*cmdline-ranges* *[range]* *E16* *E493*

有些 Ex 命令前面可以接受一个范围限定，这被称作 [range] (区间)。它由一个或多个
被 ',' 或 ';' 分割的行限定符组成。

一些基本的内容在用户手册的 |10.3| 里解释过。

						*:,* *:;*
当区间被 ';' 分割时，在解释下一个行限定符之前，光标的位置会被设置为前一个行
限定符确定的行值。这种情况不会发生在 ',' 上。例如: >
   4,/this line/
<	从第 4 行到匹配当前光标后的一个 "this line" 为止的区间。 >
   5;/that line/
<	从第 5 行到匹配第 5 行之后的一个 "that line" 为止的区间。

对大多数命令而言，默认的行限定符就是光标的位置，但是 ":write" 和 ":global" 
命令的默认值是整个文件 (1,$)。

若行限定符的个数多于命令需要的数量，则第一个 (或前几个) 限定符被忽略。

行号可以用下列符号限定:				*:range* *E14* *{address}*
	{number}	行号
	.		当前行					  *:.*
	$		文件的最后一行				  *:$*
	%		相当于 1,$ (整个文件)			  *:%*
	't		标记 t 的位置 (小写)			  *:'*
	'T		标记 T 的位置 (大写); 如果标记存在于另一个
			文件中，则不能在区间里应用。
	/{pattern}[/]	下一个 匹配 {pattern} 的行		  *:/*
	?{pattern}[?]	前一个 匹配 {pattern} 的行		  *:?*
	\/		下一个 与前一个样式匹配的行
	\?		前一个 与前一个样式匹配的行
	\&		下一个 与前一个替换样式匹配的行

这些符号后面可以跟(一个或多个) '+' 或 '-' 和一个可选的数字。该数字会与前面
的行号相加或相减。若该数字省略，则认为是 1 。

在 {pattern} 之后需要由 "/" 或 "?" 来分割匹配模式与其之后的内容。

"/" 和 "?" 前面可能有另一个地址。查找就从那里开始。使用分号的不同之处是: 光
标不会被移动。例如: >
	/pat1//pat2/	不移动光标位置，从包含 "pat1" 的行开始，向后直至找到
			包含 "pat2" 的行为止。
	7;/pat2/	从第 7 行开始，向后直至找到包含 "pat2" 的行为止。光
			标留在第 7 行。

{number} 必须在 0 和文件的总行数之间。当使用 0 (零) 的时候，大多数命令会把它
解释成 1 。把它用作计数器的命令会将它解释为零 (|:tag|，|:pop|，等)。有些命令
会把零解释为 "在第一行之前" (|:read|，搜索样式，等)。

例如: >
	.+3		光标下面三行
	/that/+1	下一个包含 "that" 的行的下一行
	.,$		从当前行直至文件末尾
	0;/that		第一个包含 "that" 的行，匹配时也包括第一行
	1;/that		从第一行开始到第一行之后(从第二行开始)包含 "that" 
			的那一行

有些命令后面可以跟一个数字。这个数字是从上一个行限定符开始计算的行数(默认值是
当前光标所在的行算起)。这些行会被作为区间被该命令处理。可以使用区间但是不使用
文件名作为参数的命令可以接受这种数(因为文件名也可能是一个数字)。

例如: >
	:s/x/X/g 5	用 'X' 替换当前行和下面四行里的 'x'。
	:23d 4		删除 23，24，25 和 26 行。


折叠和区间

如果激活了折叠功能，行号会被卷起以包括整个折叠。见 |fold-behavior|。


反向区间						*E493*

在区间里，小的数字应该出现在前面。如果不是这样，Vim 会询问你是否交换。
	Backwards range given, OK to swap ~
但在全局命令 ":g" 里不是这么做的。

为避免这个问题，可以在命令前使用 ":silent" ，任何情况下会交换区间。


计数器和区间						*N:*

如果在进入 ":" 之前输入了一个数字 count (计数器)，这种情况会被解释成:
		:.,.+(count - 1)
简单来说就是: 包括当前行，向后共计 'count' 行。例如，删除三行: >
		3:d<CR>		被翻译成: .,.+2d<CR>
<

可视模式和区间						*v_:*

{Visual}:	将可视模式中选择的区域用作命令行模式的区间。":'<,'>" 被用来
		表示这种区间。这种表示方法使得从命令历史列表里选择相似的命
		令在不同的选择区域上重复执行相同的操作成为可能。

==============================================================================
5. Ex 命令行的标志					*ex-flags*

部分 Ex 命令支持这些标志。它们在执行完命令后，打印出以光标结束的行：

	l	|:list| 风格的输出
	#	增加行号
	p	|:print|风格的输出

可以联合使用这些标志，所以 "l#" 表示增加行号且 |:list|风格的输出。

==============================================================================
5. Ex 里的特殊字符					*cmdline-special*

注意：这些是在执行的 Ex 命令行中的特殊字符。如果你想在录入的时候插入这些特殊字
符，可以使用 CTRL-R 命令。例如："%" 表示当前文件名，键入 CTRL-R % 后，立刻插入
当前文件名。见 |c_CTRL-R|。


在 Ex 命令中，下列字符在可以使用文件名的地方有特殊的意义。这些同样可以用到表
达式函数 expand() 中 |expand()|。
	%	被当前文件名取代					*:_%*
	#	被备选文件名取代					*:_#*
	#n	( n 是一个数字 ) 被第 n 个缓冲区的文件名取代。"#0" 与 "#"
		相同
	##	被参数列表里的所有文件(使用空格符分割)名取代。		*:_##*
		文件名中的空格符前面会加一个反斜杠。

注意: 这样只给出显示的文件名。如果需要完整的路径(当从另一个目录使用文件名的
时候)，你需要加 ":p"。见 |filename-modifiers|。
注意: 空格符前面会插入反斜杠，所以 Vim 命令会正确地解释文件名。但是 shell 却
不能。针对这一点你可以使用引号: >
	:!ls "%"
	:r !spell "%"

要避免 '%' 和 '#' 的特殊含义，可以在它前面插入一个反斜杠。细节: 只要有反斜杠
在这些字符前面，它们就不具备特殊含义，不管有多少个反斜杠。
	你输入:			结果	~
	   #			alternate.file
	   \#			#
	   \\#			\#

			       *:<cword>* *:<cWORD>* *:<cfile>* *<cfile>*
			       *:<sfile>* *<sfile>* *:<afile>* *<afile>*
			       *:<abuf>* *<abuf>* *:<amatch>* *<amatch>*
			       *E495* *E496* *E497* *E498* *E499* *E500*
注意: 下面这些不是特殊键，需要逐个字符输入。
	<cword>    被当前光标下的 word 代替 (类似于 |star|)
	<cWORD>    被当前光标下的 WORD 代替 (类似于 |WORD|)
	<cfile>    被当前光标下的路径名代替 (类似于 |gf| 用的方法)
	<afile>    在执行自动命令时，被用来读或写的文件的文件名取代。
	<abuf>     在执行自动命令时，被当前有效的缓冲区序号取代 (对于":r file"
		   和 ":so file" 来说是当前的缓冲区，但是被读取的文件却不在缓
		   冲区里)。
	<amatch>   在执行自动命令时，被匹配的执行的内容代替。只有在文件名不用
		   于匹配 (对于 FileType，Syntax 和 SpellFileMissing 事件) 时，
		   才与 <afile> 不同。
	<sfile>    在执行 ":source" 命令时，被替换成要被 "source" 执行的文件
		   名；
		   如果执行一个函数，那么被 "function {function-name}" 代替；
		   函数嵌套调用表示为: 
		   "function {function-name1}..{function-name2}"。注意，如果
		   <sfile> 用在函数里，那么 filename-modifiers 就没用了。

							 *filename-modifiers*
	 *:_%:* *::8* *::p* *::.* *::~* *::h* *::t* *::r* *::e* *::s* *::gs*
可以在 "%"，"#"，"#n"，"<cfile>"，"<sfile>"，"<afile>" 或 "<abuf>" 之后使用
文件名修饰符用。这些修饰符也可以和 |fnamemodify()| 函数一起用。如果 Vim 编译
的时候没有加入 |+modify_fname| 功能，则不可用。

此类修饰符按如下顺序给出:
	:p	给出文件名的全路径。必须是第一个修饰符。也会将 "~/" (Unix 和 
		VMS 系统里的 "~user/") 变成指向 home 目录的路径。若被修饰的名
		字是一个目录，则在后面加一个路径分隔符。如果文件名不存在，或
		其绝对路径不存在，那么结果不可预料。
	:8	将路径转换为 8.3 短格式 (目前仅适用于 win32)。转换的结果尽可
		能与现存路径一致。
	:~	如果可能，路径名缩减为 home 的相对路径。若文件不在 home 目录
		下，则文件名不会被改变。
	:.	如果可能，路径名缩减为当前目录的相对路径。若文件不在当前目录
		下，则文件名不会被改变。
		要想最大化缩减，可使用 ":~:." 。
	:h	文件名的头部，(除去文件名的最后一部分以及路径分隔符)
		不能与 :e，:r 或 :t 一起使用。
		可以被重复使用来删除后面的多个部分。
		如果文件名以一个路径分隔符结尾，仅删除该分隔符。这样一个目录
		名的 ":p:h" 结果是目录名本身 (没有后面的斜杠)。
		如果文件名是一个绝对路径 ( Unix 里以 "/" 开始; MS-DOS，WIN32，
		OS/2 以 "x:\" 开始；Amiga 以 "drive:" 开始 )，这些部分不会被
		删除。如果没有文件头(相对于当前路径)，则结果为空。
	:t	文件名的尾部(文件名的最后一部分)。前面必须有 :r 或 :e 。
	:r	文件名的根(除去最后的扩展名)。如果只有一个扩展名 (文件名以'.'
		开始，例如，".vimrc")，则不会被删除。可以重复使用，以删除多个
		扩展名(最后一个先被删除)。
	:e	扩展名。只有单独使用时才有意义。
		如果没有扩展名，那结果为空。
		如果文件名只是一个扩展名 (以 '.' 开始的文件名)，则结果为空。
		可以重复使用来包含更多的扩展名。如果没有足够的扩展名(但是至少
		有一个)，那么就尽可能多的包含。
	:s?pat?sub?
		用 "sub" 代替第一次出现的 "pat"。这类似于 |:s| 命令。"pat" 是
		一个正则表达式。
		可以用其它字符代替 '?'，只要该字符不出现在 "pat" 或 "sub" 里。
		在此之后，上述的修饰符可以再次使用。例如 ":p"，是替换之后的完
		整路径。
	:gs?pat?sub?
		用 "sub" 替换所有的 "pat"。其余和 ":s" 一样。

例如，如果文件名是 "src/version.c"，当前目录是 "/home/mool/vim": >
  :p			/home/mool/vim/src/version.c
  :p:.				       src/version.c
  :p:~				 ~/vim/src/version.c
  :h				       src
  :p:h			/home/mool/vim/src
  :p:h:h		/home/mool/vim
  :t					   version.c
  :p:t					   version.c
  :r				       src/version
  :p:r			/home/mool/vim/src/version
  :t:r					   version
  :e						   c
  :s?version?main?		       src/main.c
  :s?version?main?:p	/home/mool/vim/src/main.c
  :p:gs?/?\\?		\home\mool\vim\src\version.c

又例，如果文件名是 "src/version.c.gz": >
  :p			/home/mool/vim/src/version.c.gz
  :e						     gz
  :e:e						   c.gz
  :e:e:e					   c.gz
  :e:e:r					   c
  :r				       src/version.c
  :r:e						   c
  :r:r				       src/version
  :r:r:r			       src/version
<
					*extension-removal* *:_%<*
如果 "<" 跟在 "%"，"#"，"#n" 或 "CTRL-V p" 后面，那么文件的扩展名('.'之后的
内容，包括 '.' )会被删除。包含这样的功能是为了与 3.0 版本兼容，现在推荐使用
":r" 的形式。例如: >

	%		当前文件名
	%<		当前主文件名(无扩展名)
	#		当前窗口的交替文件名
	#<		同上，但无扩展名
	#31		序号为 31 的交替文件名
	#31<		同上，但无扩展名
	<cword>		光标下的单词 word
	<cWORD>		光标下的单词 WORD (见 |WORD|)
	<cfile>		光标下的路径名
	<cfile><	同上，但无扩展名
<
注意: 在需要文件名的地方，就会完成文件名的通配符扩展。在 Unix 里，除非可以在
内部时限 (考虑运行速度)，此功能会通过 shell 来完成。
也可以使用反引号，比如在 >
	:n `echo *.c`
(在 |restricted-mode| 里反引号扩展不可用)

但是扩展仅针对扩展 '%'，'#'，等字符之前的通配符。这可以避免在文件名中间扩展
通配符。如果你想扩展 <cfile> 的结果，可以给它加一个通配字符。
例如: (被选文件名是 "?readme?")
	命令		扩展为  ~
	:e #		:e ?readme?
	:e `ls #`	:e {匹配 "?readme?" 的文件}
	:e #.*		:e {匹配 "?readme?.*" 的文件}
	:cd <cfile>	:cd {光标下的文件}
	:cd <cfile>*	:cd {光标下的文件名加上 "*" 然后进行扩展}

当被扩展的参数包含一个 "!" 并且用在一个 shell 命令里 (":!cmd"，":r !cmd" 
或 ":w !cmd")，那么它会被一个反斜杠转义以免被扩展为前面使用过的命令。如果
'shell' 选项包含 "sh"，会执行两次转义，以避免 shell 扩展 "!"。

							*filename-backslash*
对于文件系统使用反斜杠作为目录分隔符的操作系统 (MS-DOS，Windows，OS/2) 来说，
确认反斜杠是否为转义字符就有点儿困难了。一般来说: 如果反斜杠后面跟一个普通的
字符，那么就没有特殊意义。因此 "\file\foo" 是合法文件名，没有必要输入两次反斜
杠。

一个例外是 '$' 符号。在文件名里它是一个合法的字符。但是为了避免像 "$home" 这
样的文件名被当作环境变量解释，则需要在前面加一个反斜杠。因此你需要用
"/\$home" 表示根目录下的 "$home" 文件。几个例子:

	文件名		被解释为	~
	$home		扩展为环境变量 $home 的值
	\$home		当前目录里的 "$home" 文件
	/\$home		根目录下的 "$home" 文件
	\\$home		文件 "\\"，后面跟着扩展的 $home

==============================================================================
6. 命令行窗口					*cmdline-window* *cmdwin*

在命令行窗口里，可以像编辑文本一样来编辑命令。这是一类特殊的窗口，你不能把
它当作普通窗口使用。
{not available 若编译时未加入 |+cmdline_hist| 或 |+vertsplit| 则该功能不可用}


开 启

有两种方法可以打开命令行窗口:
1. 在命令行模式里，用 'cedit' 选项所指定的键。
   在没有设置 'compatible' 的情况下，默认值是 CTRL-F 。
2. 在普通模式里，用 "q:"，"q/" 或 "q?" 命令。  *q:* *q/* *q?*
   开始编辑 Ex 命令 ("q:") 或搜索字符串 ("q/" 或 "q?")。 注意，处于记录状态
   时不能使用 ("q" 会结束记录)。

窗口里的内容是命令行的历史记录。最后一行是最近输入的命令。左面一列字符表示命
令行的类型。见: |cmdwin-char|。

如果没有设置 'insertmode' 选项，Vim 在打开之后会进入普通模式。

窗口的高度可以通过 'cmdwinheight' 选项设定(如果没有足够的空间，窗口会缩小一
点)。窗口永远都是以最大宽度出现，并且被放在命令行的上面(紧靠命令行)。


编 辑

现在你可以在窗口里移动或者编辑里面的文本了。可以在普通模式和插入模式进行这些
操作。

可以通过命令行使用 ":"，"/" 和其他命令，但却不能再打开另一个命令行窗口。因为
不能嵌套。
							*E11*
命令行窗口不是普通的窗口。你不能移动到别的窗口或编辑别的缓冲区。在命令行窗口
里，所有此类操作都被禁止。当然可以执行你在命令行窗口里输入的任何命令。


关 闭							*E199*

有很多方法可以退出命令行窗口:

<CR>		执行光标下的命令。可以在插入和普通模式里进行。
CTRL-C		在命令行模式中继续。光标下的命令被用做命令行的命令。可以在
		插入和普通模式里进行。也可以使用 ":close" 命令。不会重画窗
		口，这样命令行窗口仍然可见。
:quit		退出命令行，回到普通模式。也可以使用 ":exit"，":xit" 和
		CTRL-\ CTRL-N 命令。
:qall		除非改动了某些缓冲区，否则退出 Vim 。
:qall!		退出 Vim，放弃所做的改动。

一旦命令行窗口关闭，旧的窗口就会立刻恢复原先的大小。执行的命令会作用于调用该
命令行窗口或缓冲区，就好像没有没有命令行窗口一样(除非有一个额外的屏幕刷新)。
命令行窗口用过的缓冲区会被删除。对其中的命令所做的改动(如果没有用 <CR> 执行过)
会全部丢失。

如果你愿意执行在光标下的命令并再次打开命令行窗口，你可能会发现这个映射很有用：
>
	:map <F5> <CR>q:


其 它

命令行窗口不能用在:
- 已经存在一个命令行窗口的时候 (不能嵌套)
- 输入密钥或使用 inputsecret() 函数的时候
- 若 Vim 编译时没有加入 +vertsplit 功能

打开命令行窗口的时候，会自动设置下面的选项:
'filetype'	当编辑 Ex 命令时，会设置为 "vim"; 这样会启用对 Vim 脚本的语法
		加亮。
'rightleft'	关
'modifiable'	开
'buftype'	"nofile"
'swapfile'	关

将命令窗口缓冲区的内容写到文件是允许的。这也是一个保存命令历史记录的好办法。

如果 'wildchar' 选项设置为 <Tab>，并且命令行窗口用于 Ex 命令，那么会在命令行
窗口里加入两个映射用于命令补全，如下: >
	:imap <buffer> <Tab> <C-X><C-V>
	:nmap <buffer> <Tab> a<C-X><C-V>
注意，在普通模式里敲 <Tab> 键会在下一个字符上补全。这样的话，就可以在行尾
进行补全了。
如果你不想要这些映射，可用下面的命令将它们禁用: >
	au CmdwinEnter [:>] iunmap <Tab>
	au CmdwinEnter [:>] nunmap <Tab>
你可以把这几行命令放到你的 vimrc 文件中。

在命令行窗口里，你不能用鼠标把光标放到另一个窗口里，或者拽动其它窗口的状态栏。
你可以拽动命令行窗口自己的状态栏以及命令行窗口上面的状态栏来改变命令行窗口的
大小，但对其它窗口无效。


自 动 命 令

使用两种自动命令事件: |CmdwinEnter| 和 |CmdwinLeave|。因为这是个特殊类型的
窗口，所以不会触发 WinEnter，WinLeave，BufEnter 和 BufLeave 事件。你可以使用
Cmdwin 事件对命令行窗口进行特殊的设置。小心不要引起副作用！
例如: >
	:au CmdwinEnter :  let b:cpt_save = &cpt | set cpt=v
	:au CmdwinLeave :  let &cpt = b:cpt_save
设置 'complete' 选项，以便在插入模式用 CTRL-N 进行命令行匹配。
另一个例子: >
	:au CmdwinEnter [/?]  startinsert
这将使 Vim 在打开命令行窗口时切换到插入模式。

						*cmdwin-char*
下面这些字符用于表示命令行的种类:
	:	普通的 Ex 命令
	>	调试模式的命令 |debug-mode|
	/	向前查找字符串
	?	向后查找字符串
	=	"= 表达式 |expr-register|
	@	|input()| 字符串
	-	|:insert| 或 |:append| 的文本

 vim:tw=78:ts=8:ft=help:norl:
