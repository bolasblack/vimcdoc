*undo.txt*      For Vim version 7.0.   最后更改：2006.07.26
 

		     Vim 参考手册    作者：Bram Moolenaar
			（译者: jwdu, tocer http://vimcdoc.sf.net） 

撤销和重做							*undo-redo*

在用户手册的 |02.5| 节对它们的基本操作有解释。

1. 撤销和重做操作的命令		|undo-commands|
2. 撤销操作的两种方法		|undo-two-ways|
3. 撤销块			|undo-blocks|
4. 撤销分支			|undo-branches|
5. 撤销操作的解释		|undo-remarks|

==============================================================================
1. 撤销和重做命令					*undo-commands*

<Undo>		或					*undo* *<Undo>* *u*
u			撤销 [count] 次更改。 		{Vi: 仅有一级}

							*:u* *:un* *:undo*
:u[ndo]			撤销一次更改。  		{Vi: 仅有一级}

:u[ndo] {N}		撤销 {N} 次更改。{N} 的含义参见|undo-branches|。
			{Vi: 无效}

							*CTRL-R*
CTRL-R			重做 [count] 次被撤销的更改。	{Vi: 刷新屏幕}

							*:red* *:redo* *redo*
:red[o]			重做一个被撤销的更改。		{Vi: 没有 redo}

							*U*
U			撤销最近对特定行所作的一系列更改。
			{Vi: 仅当这些修改不超出该行的范围}

由于最近所作的更改是被记住的，因此，你可以应用上面的撤销和重做命令把文件倒转到
你所作每次更改以前的状态。当然，你也可以重新应用这些修改，把文件重做到执行撤销
操作以前的状态。

对于撤销/重做 （undo/redo） 来说，"U" 命令和其他命令是同等对待的。所以 "u" 可
以撤销一个 "U" 命令、'CTRL-R' 也可以重做对 "U" 命令的撤销。当 "U"、"u" 和
'CTRL-R' 三个命令混合使用时，你将注意到 "U" 命令决意将被该行还原到前一个 "U"
命令之前的状态。这或许会令你困惑。多试试，你会习惯的。

"U" 命令总是把缓冲区标记为已改变。即使它把修改过的缓冲区重做到未改变的状态也是
如此。为此，只有使用 "u" 命令，才能令缓冲区正确地回复到未改变的标记。

==============================================================================
2. 撤销操作的两种方法					*undo-two-ways*

撤销和重做的工作模式依赖于 'cpoptions' 中 'u' 标志。这里有两种模式，Vim 模式
（不包含 'u' 命令）和 Vi-兼容模式（包含 'u' 命令）。在 Vim 模式下，"uu" 命令撤
销两次改变，在 Vi-兼容模式下，"uu" 命令什么也不做（撤销第一次撤销）。

不包含 'u' 的 Vim 模式：
及时的撤销命令可以回到先前的状态。你也可以使用重做命令再次前进。不过，如果在撤
销命令后你做了一个新的改变，重做上次的撤销便不再可能。

包含 'u' 的 Vi-兼容模式：
撤销命令撤销包含以前的撤销命令在内的任何更改。重做命令重复以前的撤销命令。但它
_不_重复一个改变命令，如果你想如此，用 "." 命令。

举例		Vim 模式		Vi-兼容 模式	~
"uu"		两次撤销		空操作
"u CTRL-R"	空操作			两次撤销

原理:	Nvi 使用 "."  命令而不是 CTRL-R 。不幸的是，这不是 Vi 兼容的。例如
	"dwdwu." 命令，在 Vi 中删除两个词，但在 Nvi 中，它什么也不做。

==============================================================================
3. 撤销块						*undo-blocks*

一个撤销命令通常撤销一个键入的命令，不论这个命令造成多少改变。这个可以撤销的改
变序列构成了一个撤销块。所以如果键入的命令调用一个函数，那么在这个函数中的所有
命令全部被撤销。

如果你想编写一个函数或者脚本，使其无法撤销，但是可以撤销其生效之前的改变，可以
使用这个命令：

						*:undoj* *:undojoin* *E790*
:undoj[oin]		连接之前和之后的撤销块。
			警告：小心使用，它可能会使撤销不正常。不要在撤销和重做
			之后使用这个命令。
			{Vi: 无效}

This is most useful when you need to prompt the user halfway a change.  
例如，在一个调用|getchar()|的函数中。要保证函数生效前后的改变是相关联的。

这个命令无法应用到自身，因为下一个按键将再次造成改变。但是你可以向下面那样操作：
>
	:undojoin | delete

在此命令后执行 "u" 命令会撤销删除和前一个改变。

==============================================================================
4. 撤销分支					*undo-branches* *undo-tree*

以上我们只讨论了单线的撤销/重做。但是有可能会发生分支。如果你撤销了一些改变，
然后发生了新的改变时就会发生这种情况。撤销改变发生了分支。你可以使用下面的命令
进入分支中。

这在用户手册中有解释：|usr_32.txt|。

							*:undol* *:undolist*
:undol[ist]		列出改变树中的分支：
				编号  改变         时间 ~
				4      10	 10:34:11
				18     4	 11:01:46

			“编号”列表示改变的编号。该编号持续增加，用于表示某个
			可撤销的改变，参见|:undo|。
			“改变”列表示从改变的起始点起的第几次改变。
			“时间”列表示本次改变的时间。

							*g-*
g-			转到以前的文本状态。跟一个数字表示重复多次。{Vi: 无效}
							*:ea* *:earlier*
:earlier {count}	转到 {count} 次前的文本状态。
:earlier {N}s		转到 {N} 秒前的文本状态。
:earlier {N}m		转到 {N} 分钟前的文本状态。
:earlier {N}h		转到 {N} 小时前的文本状态。

							*g+*
g+			转到以后的文本状态。跟一个数字表示重复多次。{Vi: 无效}
							*:lat* *:later*
:later {count}		转到 {count} 次后的文本状态。
:later {N}s		转到 {N} 秒后的文本状态。
:later {N}m		转到 {N} 分钟后的文本状态。
:later {N}h		转到 {N} 小时后的文本状态。


注意 如果由于 'undolevels' 选项，撤销信息被清空，那么文本状态将无法访问。

如果通过时间跳转显示在同一时间发生多个改变，不要奇怪。通过撤销树跳转然后又做
了新的改变后就会发生这种情况。

例子

从这一行开始：
	one two three ~

按三次 "x" 删除第一个单词：
	ne two three ~
	e two three ~
	 two three ~

现在，按三次 "u" 恢复：
	e two three ~
	ne two three ~
	one two three ~

按三次 "x" 删除第二个单词：
	one wo three ~
	one o three ~
	one  three ~

现在，按三次 "g-" 恢复：
	one o three ~
	one wo three ~
	 two three ~

现在，回到了第一个撤销分支，在删除 "one" 之后。重复 "g="，恢复到原始文本：
	e two three ~
	ne two three ~
	one two three ~

使用 ":later 1h" 跳到最后一次改变:
	one  three ~

使用 ":earlier 1h" 再次回到开始：
	one two three ~


注意 使用 "u" 和 CTRL-R 无法得到全部可能的文本状态，但是重复 "g-" 和 "g+" 却可
以。

==============================================================================
5. 撤销操作的解释					*undo-remarks*

能记忆的最大改变次数由 'undolevels' 选项决定。如果它的值是零，我们总是运行在
Vi-兼容模式。如果它的值是负的，任何撤销都是不可能的。这只有在内存紧张的时候适
用。

当前缓冲区的位置标记 ('a 至 'z) 随文本一起被保存和复原。{Vi 的做法稍有不同}

当所有的改变都被撤销时，缓冲区被标记为未改变。这时可以使用 ":q" 而不一定是
":q!" 退出 Vim 。{Vi 并非如此} 注意未改变是相对文件的最后写入而言的。在写入
":w" 后紧跟的撤销 "u"，实际上改变了被写入以后缓冲区的状态。因此，此时缓冲区应
被视为已改变。

当使用手动 |folding| 时，折叠不会被保存和复原。只有完全发生折叠内部的改变才不
会影响该折叠，因为它开头和最后一行没有改变。

数字编号的寄存器也可以被用作撤销删除操作。你每一次删除文本，该文本被放在 "1 寄
存器中。同样的，"1 寄存器的内容被移到 "2 寄存器，依次类推。"9 寄存器的内容则会
丢失。现在，你可以通过命令 '"1P' 得到最近删除的文本。（如果被删除的内容来自最
近的删除或复制操作，'P' 或 'p' 同样也可得到你要的结果，因为他们会复制未命名寄
存器的内容）。使用'"3P' 可以得到三个删除操作之前的文本。

							*redo-register*
如果你想得到多于一处被删除文本的内容，你可以使用重复命令 "." 一个特殊的特性：
它会递增所使用寄存器内的序号。所以，你如果先使用 ""1P" ，那么接下来的 "." 就意
味着 '"2P 。重复这将会造成所有被编号的寄存器被插入。

例如：	如果你用 'dd....' 删除了内容（五行文本），那么用 '"1P....' 可以重做。

如果你不知道被删除的内容在哪一个寄存器，你可以用 |:display| 命令。还有一个方法
就是先试第一个寄存器 '"1P' ，如果不对，用 'u.' 命令。这将会移走第一次放进的内
容，然后在第二个寄存器上重复 put 命令。重复使用 'u.' 直到你得到想要的内容。

 vim:tw=78:ts=8:ft=help:norl:
